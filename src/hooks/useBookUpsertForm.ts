import { useCallback, useEffect, useState } from "react";
import { EmptyBookItem, InitialValidItem, uiStateType } from "../types/book";
import {
  BookFormItem,
  BookItemForDB,
  CreateBookItem,
  EmptyBookFormItem,
  FormEventType,
  InputType,
  onChangeType,
  PreviewUrlType,
} from "../types/upsertBook";
import { supabase } from "./useBookFetch";
import { uploadFileToStorage } from "../utils/storage";
import { useAlertProvider } from "../context/AlertContext";
import { useAuth } from "../context/AuthContext";
// import { useBookProvider } from "../context/BookContext";

export const useBookUpsertForm = (
  bookToEdit?: BookFormItem,
  bookId?: string,
  onSuccess?: () => void,
  toggleForm?: () => void
) => {
  const [form, setForm] = useState<BookFormItem>(
    bookToEdit ?? EmptyBookFormItem
  );
  const [formValid, setFormValid] = useState(InitialValidItem);
  const [previewUrl, setPreviewUrl] = useState<PreviewUrlType>("");
  const [uiState, setUIState] = useState<uiStateType>({
    isLoading: false,
    error: "",
  });
  const isEditing = !!bookId;
  const { onShowAlert } = useAlertProvider();
  const { user } = useAuth();

  // form.price and form.quantity state expects strings but bookToEdit objects returns numbers
  // For that reason we make the conversion as a side-effect whenever bookToEdit changes.
  //   Same thing for the previewUrl state which only accepts strings
  useEffect(() => {
    if (
      bookToEdit &&
      typeof bookToEdit.image_url === "string" &&
      !previewUrl // Only if it's not already set
    ) {
      setPreviewUrl(bookToEdit.image_url);
    }
  }, [bookToEdit, previewUrl]);

  //   This is a simple event handler for capturing all text fields except for the "file"
  const handleTextChange = useCallback((event: onChangeType) => {
    const { value, name } = event.target;
    setForm((prev) => ({ ...prev, [name]: value }));
    setFormValid((prev) => ({ ...prev, [name]: true }));
  }, []);

  //   This is a simple event handler for capturing the uploaded file
  // I ensure to update the form state & validity without mutating it by using ...rest
  //   In order to show a preview of the uploaded state, I also update the preViewUrl state
  const handleFileChange = useCallback((event: InputType) => {
    const file = event.target.files?.[0];
    if (file) {
      setForm((prev) => ({ ...prev, image_url: file }));
      setFormValid((prev) => ({ ...prev, image_url: true }));
      const objectUrl = URL.createObjectURL(file);
      setPreviewUrl(objectUrl);
      console.log(objectUrl);
    }
  }, []);

  //   This handler allows the user to remove the uploaded file instantly!
  const clearFileUploader = useCallback(() => {
    setPreviewUrl("");
  }, []);

  // The manual validation in this file first checks that all fields are NOT empty.
  // It then specifically checks quantity and price that they are numbers (0-9)
  //
  const handleValidation = () => {
    const newFormValid = { ...formValid };

    Object.entries(form).forEach(([key, value]) => {
      // Skip validation for 'id' field as it's auto-generated by the database
      if (key === "id") {
        newFormValid[key as keyof typeof newFormValid] = true;
        return;
      }

      const trimmedValue = value != null ? value.toString().trim() : "";

      // 1. Check for empty fields
      if (!trimmedValue) {
        newFormValid[key as keyof typeof newFormValid] = false;
        return;
      }

      // 2. Field-specific validation
      if (["price", "quantity"].includes(key)) {
        const regex = /^\d+(\.\d{1,2})?$/;
        const isValidNumber = regex.test(trimmedValue);
        newFormValid[key as keyof typeof newFormValid] = isValidNumber;
        return;
      }

      // 3. validate the image field
      if (key === "image_url") {
        if (value instanceof File) {
          // New file upload - validate file type
          const allowedTypes = ["image/jpeg", "image/png", "image/jpg"];
          newFormValid.image_url = allowedTypes.includes(value.type);
          return;
        } else if (typeof value === "string" && value.trim()) {
          // Existing image URL - consider it valid if not empty
          newFormValid.image_url = true;
          return;
        } else {
          // No image provided
          newFormValid.image_url = false;
          return;
        }
      }
      // Default to true if value exists and passes above checks
      newFormValid[key as keyof typeof newFormValid] = true;
    });

    setFormValid(newFormValid);

    // Return overall validity
    return Object.values(newFormValid).every(Boolean);
  };

  const clearForm = () => {
    setForm(EmptyBookItem);
    setFormValid(InitialValidItem);
    setPreviewUrl("");
  };

  // This abstracted logic conditionally handles UPDATE & CREATE
  //  id is only needed when editing. It returns a response from supabase
  const upsertBook = async (
    finalData: BookItemForDB | CreateBookItem,
    id?: string
  ) => {
    return isEditing
      ? await supabase.from("books_inventory").update(finalData).eq("id", id)
      : await supabase.from("books_inventory").insert([finalData]);
  };

  // The handler responsible for sending data to the database
  // The handler calls the appropriate helper func like:
  // "handleValidation, uploadFileToStorage, upsertBook"
  const handleSubmit = async (event: FormEventType) => {
    event.preventDefault();
    setUIState({ isLoading: true, error: "" });
    const isValid = handleValidation();
    if (!isValid) {
      onShowAlert({
        message: "Failed: Please check all fields",
        type: "error",
        visible: true,
      });
      setUIState({ isLoading: false, error: "Form Validation Failed!" });

      return;
    }

    let imageUrl = "";
    // First check if the image was uploaded by the user
    // We grab that file and upload it to Supabase storage and get a URL.
    if (form.image_url && form.image_url instanceof File) {
      const userId = user?.id;
      const uploadedUrl = await uploadFileToStorage(
        form.image_url,
        userId as string
      );
      if (!uploadedUrl) {
        onShowAlert({
          message: "Failed to upload the image!",
          type: "error",
          visible: true,
        });
        setUIState({ isLoading: false, error: "Failed to upload image" });
        return;
      }
      imageUrl = uploadedUrl;
      // Here the alternative is that we have a string so we keep it and skip uploading the file
      // We know the form state has the latest update since we injected it with "bookToEdit" so we use it to update imageUrl
    } else if (typeof form.image_url === "string") {
      imageUrl = form.image_url;
    }

    // Convert price and quantity back to numbers for database
    const { ...rest } = form;
    const finalData = {
      ...rest,
      user_id: user?.id,
      image_url: imageUrl,
      price: Number(form.price),
      quantity: Number(form.quantity),
      updated_at: new Date().toISOString(),
    } as BookItemForDB | CreateBookItem;

    const { error } = await upsertBook(finalData, bookId);

    if (error) {
      onShowAlert({
        message: error.message,
        type: "error",
        visible: true,
      });
      setUIState({ isLoading: false, error: error.message });

      return;
    }
    if (onSuccess && toggleForm) {
      onShowAlert({
        message: `${
          isEditing
            ? "Book edited successfully."
            : "New book created successfully!"
        }`,
        type: "success",
        visible: true,
      });
      onSuccess();
      clearForm();
      toggleForm();
      setUIState({ isLoading: false, error: "" });
    }
  };
  return {
    handleFileChange,
    handleTextChange,
    handleSubmit,
    form,
    formValid,
    clearForm,
    previewUrl,
    clearFileUploader,
    formUiState: uiState,
  };
};
