import React, { useCallback, useEffect, useState } from "react";
import {
  BookItem,
  EmptyBookItem,
  InitialValidItem,
  uiStateType,
} from "../types/book";
import {
  BookItemForDB,
  CreateBookItem,
  InputType,
  onChangeType,
  PreviewUrlType,
} from "../types/upsertBook";
import { supabase } from "./useBookFetch";
import { uploadFileToStorage } from "../utils/storage";
// import { useBookProvider } from "../context/BookContext";

export const useBookForm = (
  bookToEdit?: BookItem,
  onSuccess?: () => void,
  toggleForm?: () => void
) => {
  const [form, setForm] = useState<BookItem>(bookToEdit ?? EmptyBookItem);
  const [formValid, setFormValid] = useState(InitialValidItem);
  const [previewUrl, setPreviewUrl] = useState<PreviewUrlType>("");
  const [uiState, setUIState] = useState<uiStateType>({
    isLoading: false,
    error: "",
  });
  const isEditing = !!bookToEdit?.id;

  // form.price and form.quantity state expects strings but bookToEdit objects returns numbers
  // For that reason we make the conversion as a side-effect whenever bookToEdit changes.
  //   Same thing for the previewUrl state which only accepts strings
  useEffect(() => {
    if (bookToEdit) {
      setForm({
        ...bookToEdit,
        price: String(bookToEdit.price),
        quantity: String(bookToEdit.quantity),
      });
      setPreviewUrl(String(bookToEdit.image_url));
    }
  }, [bookToEdit]);

  //   This is a simple event handler for capturing all text fields except for the "file"
  const handleTextChange = useCallback((event: onChangeType) => {
    const { value, name } = event.target;
    setForm((prev) => ({ ...prev, [name]: value }));
    setFormValid((prev) => ({ ...prev, [name]: true }));
  }, []);

  //   This is a simple event handler for capturing the uploaded file
  // I ensure to update the form state & validity without mutating it by using ...rest
  //   In order to show a preview of the uploaded state, I also update the preViewUrl state
  const handleFileChange = useCallback((event: InputType) => {
    const file = event.target.files?.[0];
    if (file) {
      setForm((prev) => ({ ...prev, image_url: file }));
      setFormValid((prev) => ({ ...prev, image_url: true }));
      const objectUrl = URL.createObjectURL(file);
      setPreviewUrl(objectUrl);
    }
  }, []);

  //   This handler allows the user to remove the uploaded file instantly!
  const clearFileUploader = useCallback(() => {
    setPreviewUrl("");
  }, []);

  // The manual validation in this file first checks that all fields are NOT empty.
  // It then specifically checks quantity and price that they are numbers (0-9)
  //
  const handleValidation = () => {
    const newFormValid = { ...formValid };

    Object.entries(form).forEach(([key, value]) => {
      // Skip validation for 'id' field as it's auto-generated by the database
      if (key === "id") {
        newFormValid[key as keyof typeof newFormValid] = true;
        return;
      }

      const trimmedValue = value.toString().trim();

      // 1. Check for empty fields
      if (!trimmedValue) {
        newFormValid[key as keyof typeof newFormValid] = false;
        return;
      }

      // 2. Field-specific validation
      if (["price", "quantity"].includes(key)) {
        const regex = /^\d+(\.\d{1,2})?$/;
        const isValidNumber = regex.test(trimmedValue);
        newFormValid[key as keyof typeof newFormValid] = isValidNumber;
        return;
      }

      // 3. validate the image field
      if (key === "image_url") {
        if (value instanceof File) {
          // New file upload - validate file type
          const allowedTypes = ["image/jpeg", "image/png", "image/jpg"];
          newFormValid.image_url = allowedTypes.includes(value.type);
          return;
        } else if (typeof value === "string" && value.trim()) {
          // Existing image URL - consider it valid if not empty
          newFormValid.image_url = true;
          return;
        } else {
          // No image provided
          newFormValid.image_url = false;
          return;
        }
      }
      // Default to true if value exists and passes above checks
      newFormValid[key as keyof typeof newFormValid] = true;
    });

    setFormValid(newFormValid);

    // Return overall validity
    return Object.values(newFormValid).every(Boolean);
  };

  const clearForm = () => {
    setForm(EmptyBookItem);
    setFormValid(InitialValidItem);
    setPreviewUrl("");
  };

  // This abstracted logic conditionally handles UPDATE & CREATE
  //  id is only needed when editing. It returns a response from supabase
  const upsertBook = async (
    finalData: BookItemForDB | CreateBookItem,
    id?: string
  ) => {
    return isEditing
      ? await supabase.from("books_inventory").update(finalData).eq("id", id)
      : await supabase.from("books_inventory").insert([finalData]);
  };

  // The handler responsible for sending data to the database
  // The handler calls the appropriate helper func like:
  // "handleValidation, uploadFileToStorage, upsertBook"
  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setUIState({ isLoading: true, error: "" });
    const isValid = handleValidation();
    if (!isValid) {
      alert("Form Validation Failed!");
      setUIState({ isLoading: false, error: "Form Validation Failed!" });

      return;
    }

    let imageUrl = "";
    // First check if the image was uploaded by the user
    // We grab that file and upload it to Supabase storage and get a URL.
    if (form.image_url && form.image_url instanceof File) {
      const uploadedUrl = await uploadFileToStorage(form.image_url);
      if (!uploadedUrl) {
        alert("Failed to upload image");
        setUIState({ isLoading: false, error: "Failed to upload image" });
        return;
      }
      imageUrl = uploadedUrl;
      // Here the alternative is that we have a string so we keep it and skip uploading the file
      // We know the form state has the latest update since we injected it with "bookToEdit" so we use it to update imageUrl
    } else if (typeof form.image_url === "string") {
      imageUrl = form.image_url;
    }

    // Convert price and quantity back to numbers for database
    // id is passed as optional because it's only required when editing a book
    const { id, ...rest } = form;
    const finalData = {
      ...rest,
      image_url: imageUrl,
      price: Number(form.price),
      quantity: Number(form.quantity),
    } as BookItemForDB | CreateBookItem;

    const { error } = await upsertBook(finalData, id);

    if (error) {
      console.error("Supabase error:", error);
      alert(error.message);
      setUIState({ isLoading: false, error: error.message });

      return;
    }
    // alert(isEditing ? "Book Edited" : "New Book Created");
    if (onSuccess && toggleForm) {
      onSuccess();
      clearForm();
      toggleForm();
      setUIState({ isLoading: false, error: "" });
    }
  };
  return {
    handleFileChange,
    handleTextChange,
    handleSubmit,
    form,
    formValid,
    clearForm,
    previewUrl,
    clearFileUploader,
    formUiState: uiState,
  };
};
