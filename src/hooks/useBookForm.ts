import React, { useCallback, useEffect, useState } from "react";
import { BookItem, EmptyBookItem, InitialValidItem } from "../types/book";
import {
  BookItemForDB,
  CreateBookItem,
  InputType,
  onChangeType,
  PreviewUrlType,
} from "../types/createBook";
import { supabase } from "./useBookFetch";
import { uploadFileToStorage } from "../utils/storage";

export const useBookForm = (
  bookToEdit?: BookItem,
  onSuccess?: () => void,
  toggleForm?: () => void
) => {
  const [form, setForm] = useState<BookItem>(bookToEdit ?? EmptyBookItem);
  const [formValid, setFormValid] = useState(InitialValidItem);
  const [previewUrl, setPreviewUrl] = useState<PreviewUrlType>("");
  const isEditing = !!bookToEdit?.id;

  // form.price and form.quantity state expects strings but bookToEdit objects returns numbers
  // For that reason we make the conversion as a side-effect whenever bookToEdit changes.
  //   Same thing for the previewUrl state which only accepts strings
  useEffect(() => {
    if (bookToEdit) {
      setForm({
        ...bookToEdit,
        price: String(bookToEdit.price),
        quantity: String(bookToEdit.quantity),
      });
      setPreviewUrl(String(bookToEdit.image_url));
    }
  }, [bookToEdit]);

  //   This is a simple event handler for capturing all text fields except for the "file"
  const handleTextChange = useCallback((event: onChangeType) => {
    const { value, name } = event.target;
    setForm((prev) => ({ ...prev, [name]: value }));
    setFormValid((prev) => ({ ...prev, [name]: true }));
  }, []);

  //   This is a simple event handler for capturing the uploaded file
  // I ensure to update the form state & validity without mutating it by using ...rest
  //   In order to show a preview of the uploaded state, I also update the preViewUrl state
  const handleFileChange = useCallback((event: InputType) => {
    const file = event.target.files?.[0];
    if (file) {
      setForm((prev) => ({ ...prev, image_url: file }));
      setFormValid((prev) => ({ ...prev, image_url: true }));
      const objectUrl = URL.createObjectURL(file);
      setPreviewUrl(objectUrl);
    }
  }, []);

  //   This handler allows the user to remove the uploaded file instantly!
  const clearFileUploader = useCallback(() => {
    setPreviewUrl("");
  }, []);

  // The manual validation in this file first checks that all fields are NOT empty.
  // It then specifically checks quantity and price that they are numbers (0-9)
  //
  const handleValidation = () => {
    const newFormValid = { ...formValid };

    Object.entries(form).forEach(([key, value]) => {
      // Skip validation for 'id' field as it's auto-generated by the database
      if (key === "id") {
        newFormValid[key as keyof typeof newFormValid] = true;
        return;
      }

      const trimmedValue = value.toString().trim();

      // 1. Check for empty fields
      if (!trimmedValue) {
        newFormValid[key as keyof typeof newFormValid] = false;
        return;
      }

      // 2. Field-specific validation
      if (["price", "quantity"].includes(key)) {
        const regex = /^\d+(\.\d{1,2})?$/;
        const isValidNumber = regex.test(trimmedValue);
        newFormValid[key as keyof typeof newFormValid] = isValidNumber;
        return;
      }

      // 3. validate the image field
      if (key === "image_url") {
        if (value instanceof File) {
          // New file upload - validate file type
          const allowedTypes = ["image/jpeg", "image/png", "image/jpg"];
          newFormValid.image_url = allowedTypes.includes(value.type);
          return;
        } else if (typeof value === "string" && value.trim()) {
          // Existing image URL - consider it valid if not empty
          newFormValid.image_url = true;
          return;
        } else {
          // No image provided
          newFormValid.image_url = false;
          return;
        }
      }
      // Default to true if value exists and passes above checks
      newFormValid[key as keyof typeof newFormValid] = true;
    });

    setFormValid(newFormValid);

    // Return overall validity
    return Object.values(newFormValid).every(Boolean);
  };

  // This abstracted logic conditionally handles UPDATE & CREATE
  const upsertBook = async (data: BookItemForDB | CreateBookItem) => {
    if (isEditing) {
      return await supabase
        .from("books_inventory")
        .update(data as BookItemForDB)
        .eq("id", (data as BookItemForDB).id);
    } else {
      return await supabase.from("books_inventory").insert([data]);
    }
  };
  //
  const clearForm = () => {
    setForm(EmptyBookItem);
    setFormValid(InitialValidItem);
    setPreviewUrl("");
  };

  // The handler responsible for sending data to the database
  // The handler calls the appropriate helper func like:
  // "handleValidation, uploadFileToStorage, upsertBook"
  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const isValid = handleValidation();
    if (!isValid) {
      alert("Form Validation Failed!");
      return;
    }

    let imageUrl = "";
    if (form.image_url && form.image_url instanceof File) {
      const uploadedUrl = await uploadFileToStorage(form.image_url);
      if (!uploadedUrl) {
        alert("Failed to upload image");
        return;
      }
      imageUrl = uploadedUrl;
    } else if (typeof form.image_url === "string") {
      imageUrl = form.image_url; // preserve existing image's url on edit
    }

    // Convert price and quantity back to numbers for database
    const finalData = isEditing
      ? ({
          ...form,
          image_url: imageUrl,
          price: Number(form.price),
          quantity: Number(form.quantity),
        } as BookItemForDB)
      : ({
          // Exclude id field for new books - let Supabase auto-generate it
          title: form.title,
          author: form.author,
          category: form.category,
          description: form.description,
          image_url: imageUrl,
          price: Number(form.price),
          quantity: Number(form.quantity),
        } as CreateBookItem);

    const { error, data } = await upsertBook(finalData);

    console.log("Supabase response:", { error, data });

    if (error) {
      console.error("Supabase error:", error);
      alert(error.message);
      return;
    }

    alert(isEditing ? "Book Edited" : "New Book Created");
    if (onSuccess && toggleForm) {
      onSuccess();
      clearForm();
      toggleForm();
    }
  };
  return {
    handleFileChange,
    handleTextChange,
    handleSubmit,
    form,
    formValid,
    clearForm,
    previewUrl,
    clearFileUploader,
  };
};
